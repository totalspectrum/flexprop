'' automatically generated by fastspin v 3.9.17 on Sat Feb  2 22:22:55 2019
'' command line: /home/ersmith/Parallax/spin2cpp/build/fastspin -w -2 multiply.spin 

con
	__MBOX_SIZE = 6
	__STACK_SIZE = 1
var
  long __mbox[__MBOX_SIZE]   ' mailbox for communicating with remote COG
  long __objmem[0]          ' space for hub data in COG code
  long __stack[__STACK_SIZE] ' stack for new COG
  byte __cognum              ' 1 + the ID of the running COG (0 if nothing running)

'' Code to start the object running in its own COG
'' This must always be called before any other methods
pub __coginit(id)
  if (__cognum == 0) ' if the cog isn't running yet
    __fixup_addresses
    longfill(@__mbox, 0, __MBOX_SIZE)
    __mbox[1] := @entry
    __mbox[2] := @__objmem
    __mbox[3] := @__stack
    if (id < 0)
      id := cognew(@entry, @__mbox)
    else
      coginit(id, @entry, @__mbox) ' actually start the cog
    __cognum := id + 1
  return id

pub __cognew
  return __coginit(-1)

'' Code to stop the remote COG
pub __cogstop
  if __cognum
    __lock  ' wait until everyone else is finished
    cogstop(__cognum~ - 1)
    __mbox[0] := 0
    __cognum := 0

'' Code to lock access to the PASM COG
'' The idea here is that (in theory) multiple Spin bytecode threads might
'' want access to the PASM COG, so this lock mackes sure they don't step on each other.
'' This method also makes sure the remote COG is idle and ready to receive commands.
pri __lock
  repeat
    repeat until __mbox[0] == 0   ' wait until no other Spin code is using remote
    __mbox[0] := __cognum         ' try to claim it
  until __mbox[0] == __cognum     ' make sure we really did get it

  repeat until __mbox[1] == 0     ' now wait for the COG itself to be idle

'' Code to release access to the PASM COG
pri __unlock
  __mbox[0] := 0

'' Check to see if the PASM COG is busy (still working on something)
pub __busy
  return __mbox[1] <> 0

'' Code to send a message to the remote COG asking it to perform a method
'' func is the PASM entrypoint of the method to perform
'' if getresult is nonzero then we wait for the remote COG to answer us with a result
'' if getresult is 0 then we continue without waiting (the remote COG runs in parallel
'' We must always call __lock before this, and set up the parameters starting in __mbox[2]
pri __invoke(func, getresult) : r
  __mbox[1] := func - @entry     ' set the function to perform (NB: this is a HUB address)
  if getresult                   ' if we should wait for an answer
    repeat until __mbox[1] == 0  ' wait for remote COG to be idle
    r := __mbox[2]               ' pick up remote COG result
  __unlock                       ' release to other COGs
  return r

'' Code to convert Spin relative addresses to absolute addresses
'' The PASM code contains some absolute pointers internally; but the
'' regular Spin compiler cannot emit these (bstc and fastspin can, with the
'' @@@ operator, but we don't want to rely on having those compilers).
'' So the compiler inserts a chain of fixups, with each entry having the Spin
'' relative address in the low word, and a pointer to the next fixup in the high word.
'' This code follows that chain and adjusts the relative addresses to absolute ones.
pri __fixup_addresses | ptr, nextptr, temp
  ptr := __fixup_ptr[0]
  repeat while (ptr)      ' the fixup chain is terminated with a 0 pointer
    ptr := @@ptr          ' point to next fixup
    temp := long[ptr]     ' get the data
    nextptr := temp >> 16 ' high 16 bits contains link to next fixup
    temp := temp & $ffff  ' low 16 bits contains real pointer
    long[ptr] := @@temp   ' replace fixup data with real pointer
    ptr := nextptr
  __fixup_ptr[0] := 0 ' mark fixups as done

'--------------------------------------------------
' Stub functions to perform remote calls to the COG
'--------------------------------------------------

pub builtinmul(a, b) : r0, r1, r2
  __lock
  __mbox[2] := a
  __mbox[3] := b
  __mbox[1] := @pasm_builtinmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

pub cordicmul(a, b) : r0, r1, r2
  __lock
  __mbox[2] := a
  __mbox[3] := b
  __mbox[1] := @pasm_cordicmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

pub hwmul(a, b) : r0, r1, r2
  __lock
  __mbox[2] := a
  __mbox[3] := b
  __mbox[1] := @pasm_hwmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

pub swmul(a, b) : r0, r1, r2
  __lock
  __mbox[2] := a
  __mbox[3] := b
  __mbox[1] := @pasm_swmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

'--------------------------------------------------
' The converted object (Spin translated to PASM)
' This is the code that will run in the remote COG
'--------------------------------------------------

dat
	cogid	$1d0
	coginit	$1d0,##$400
	orgh	$10
	long	160000000 ' clock frequency
	long	$10c3f04 ' clock mode
	orgh	$400
	org	0
entry
	mov	mboxptr, ptra
	add	mboxptr, #8
	rdlong	objptr, mboxptr
	add	mboxptr, #4
	rdlong	ptra, mboxptr
	sub	mboxptr, #8
	wrlong	#0, mboxptr
waitloop
	rdlong	mboxcmd, mboxptr wz
 if_e	jmp	#waitloop
	add	mboxptr, #4
	rdlong	arg01, mboxptr
	add	mboxptr, #4
	rdlong	arg02, mboxptr
	sub	mboxptr, #4
	shr	mboxcmd, #2
	calla	mboxcmd
	wrlong	result1, mboxptr
	add	mboxptr, #4
	wrlong	result2, mboxptr
	add	mboxptr, #4
	wrlong	result3, mboxptr
	sub	mboxptr, #12
	mov	arg01, #0
	wrlong	arg01, mboxptr
	jmp	#waitloop

pasm_builtinmul
_builtinmul
	getct	result1
	mov	_builtinmul_t, result1
	mov	muldiva_, arg01
	mov	muldivb_, arg02
	calla	#multiply_
	getct	result1
	sub	result1, _builtinmul_t
	mov	result3, result1
	mov	result1, muldiva_
	mov	result2, muldivb_
_builtinmul_ret
	reta

pasm_cordicmul
_cordicmul
	getct	result1
	mov	_cordicmul_t, result1
	qmul	arg01, arg02
	getqx	_cordicmul_lo
	getqy	result2
	getct	result1
	sub	result1, _cordicmul_t
	mov	result3, result1
	mov	result1, _cordicmul_lo
_cordicmul_ret
	reta

pasm_hwmul
_hwmul
	getct	result1
	mov	_hwmul_t, result1
	mov	_hwmul_ahi, arg01
	shr	_hwmul_ahi, #16
	mov	_hwmul_bhi, arg02
	shr	_hwmul_bhi, #16
	mov	_hwmul_lo, arg01
	mov	result2, _hwmul_ahi
	mul	_hwmul_lo, arg02
	mul	result2, _hwmul_bhi
	mul	_hwmul_ahi, arg02
	mul	_hwmul_bhi, arg01
	mov	_hwmul_a, _hwmul_ahi
	shl	_hwmul_a, #16
	shr	_hwmul_ahi, #16
	mov	_hwmul_b, _hwmul_bhi
	shl	_hwmul_b, #16
	shr	_hwmul_bhi, #16
	add	_hwmul_lo, _hwmul_a wc
	addx	result2, _hwmul_ahi
	add	_hwmul_lo, _hwmul_b wc
	addx	result2, _hwmul_bhi
	getct	result1
	sub	result1, _hwmul_t
	mov	result3, result1
	mov	result1, _hwmul_lo
_hwmul_ret
	reta

pasm_swmul
_swmul
	getct	result1
	mov	_swmul_t, result1
	mov	_swmul_lo, #0
	mov	_swmul_hi, #0
	mov	_swmul_bhi, #0
	cmp	arg01, #0 wz
 if_e	jmp	#LR__0002
LR__0001
	test	arg01, #1 wz
 if_ne	add	_swmul_lo, arg02 wc
 if_ne	addx	_swmul_hi, _swmul_bhi
	add	arg02, arg02 wc
	addx	_swmul_bhi, _swmul_bhi
	shr	arg01, #1 wz
 if_ne	jmp	#LR__0001
LR__0002
	getct	result1
	sub	result1, _swmul_t
	mov	result3, result1
	mov	result1, _swmul_lo
	mov	result2, _swmul_hi
_swmul_ret
	reta

multiply_
	mov	itmp2_, muldiva_
	xor	itmp2_, muldivb_
	abs	muldiva_, muldiva_
	abs	muldivb_, muldivb_
	qmul	muldiva_, muldivb_
	getqx	muldiva_
	getqy	muldivb_
	shr	itmp2_, #31 wz
 if_nz	neg	muldivb_, muldivb_
 if_nz	neg	muldiva_, muldiva_ wz
 if_nz	sub	muldivb_, #1
	reta

itmp1_
	long	0
itmp2_
	long	0
mboxcmd
	long	0
mboxptr
	long	0
objptr
	long	0
result1
	long	0
result2
	long	0
result3
	long	0
COG_BSS_START
	fit	496
	orgh
	org	COG_BSS_START
_builtinmul_t
	res	1
_cordicmul_lo
	res	1
_cordicmul_t
	res	1
_hwmul_a
	res	1
_hwmul_ahi
	res	1
_hwmul_b
	res	1
_hwmul_bhi
	res	1
_hwmul_lo
	res	1
_hwmul_t
	res	1
_swmul_bhi
	res	1
_swmul_hi
	res	1
_swmul_lo
	res	1
_swmul_t
	res	1
arg01
	res	1
arg02
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	496
__fixup_ptr
	long	0
